pub struct Solution;

// ------------------------------------------------------ snip ------------------------------------------------------ //

use std::cmp::Reverse;
use std::collections::VecDeque;

impl Solution {
    #[allow(clippy::if_then_some_else_none)]
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();

        // Partition graph into connected components.

        let mut states = vec![(false, false); n]; // List of `(is_infected, visited)` pair.

        for &initial in &initial {
            states[initial as u32 as usize].0 = true;
        }

        let mut queue = VecDeque::new();
        let mut affects = vec![0_u32; n];

        for mut node in 0..n {
            if let (is_infected, visited @ false) = &mut states[node] {
                *visited = true;

                let mut size = 1;
                let mut infected = if *is_infected { Ok(Some(node)) } else { Ok(None) };

                loop {
                    for (next, &connected) in graph[node].iter().enumerate() {
                        if connected != 0 {
                            if let (is_infected, next_visited @ false) = &mut states[next] {
                                if *is_infected {
                                    match infected {
                                        Ok(None) => infected = Ok(Some(next)),
                                        Ok(Some(_)) => infected = Err(()),
                                        Err(()) => {}
                                    }
                                }

                                *next_visited = true;
                                size += 1;
                                queue.push_back(next);
                            }
                        }
                    }

                    if let Some(next_node) = queue.pop_front() {
                        node = next_node;
                    } else {
                        break;
                    }
                }

                if let Ok(Some(x)) = infected {
                    affects[x] += size;
                }
            }
        }

        // Find the infected node that affects most nodes.

        (0_u32..)
            .zip(affects)
            .filter_map(|(node, size)| if size == 0 { None } else { Some((size, Reverse(node))) })
            .max()
            .map_or_else(
                || initial.iter().copied().min().unwrap() as _,
                |(_, Reverse(node))| node,
            ) as _
    }
}

// ------------------------------------------------------ snip ------------------------------------------------------ //

impl super::Solution for Solution {
    fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        Self::min_malware_spread(graph, initial)
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_solution() {
        super::super::tests::run::<super::Solution>();
    }
}
