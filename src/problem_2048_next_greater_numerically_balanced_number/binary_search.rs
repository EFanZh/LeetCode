pub struct Solution;

// ------------------------------------------------------ snip ------------------------------------------------------ //

impl Solution {
    pub fn next_beautiful_number(n: i32) -> i32 {
        const DATA: [u32; 109] = [
            1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323,
            32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122_333, 123_233, 123_323, 123_332, 132_233,
            132_323, 132_332, 133_223, 133_232, 133_322, 155_555, 212_333, 213_233, 213_323, 213_332, 221_333, 223_133,
            223_313, 223_331, 224_444, 231_233, 231_323, 231_332, 232_133, 232_313, 232_331, 233_123, 233_132, 233_213,
            233_231, 233_312, 233_321, 242_444, 244_244, 244_424, 244_442, 312_233, 312_323, 312_332, 313_223, 313_232,
            313_322, 321_233, 321_323, 321_332, 322_133, 322_313, 322_331, 323_123, 323_132, 323_213, 323_231, 323_312,
            323_321, 331_223, 331_232, 331_322, 332_123, 332_132, 332_213, 332_231, 332_312, 332_321, 333_122, 333_212,
            333_221, 422_444, 424_244, 424_424, 424_442, 442_244, 442_424, 442_442, 444_224, 444_242, 444_422, 515_555,
            551_555, 555_155, 555_515, 555_551, 666_666,
        ];

        let i = DATA.partition_point(|&x| x <= n as u32);

        DATA.get(i).copied().unwrap_or(1_224_444) as _
    }
}

// ------------------------------------------------------ snip ------------------------------------------------------ //

impl super::Solution for Solution {
    fn next_beautiful_number(n: i32) -> i32 {
        Self::next_beautiful_number(n)
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_solution() {
        super::super::tests::run::<super::Solution>();
    }
}
