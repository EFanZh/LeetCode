pub struct Solution;

// ------------------------------------------------------ snip ------------------------------------------------------ //

use std::cmp::Reverse;
use std::collections::VecDeque;

#[derive(Clone)]
enum State {
    NotVisited,
    Visited,
    Infected,
}

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        let n = graph.len();

        // Partition graph into connected components.

        let mut states = vec![State::NotVisited; n];

        for &initial in &initial {
            states[initial as u32 as usize] = State::Infected;
        }

        let mut queue = VecDeque::new();
        let mut affects = vec![0_u32; n];

        for mut node in 0..n {
            if let state @ State::NotVisited = &mut states[node] {
                *state = State::Visited;

                let mut size = 1;
                let mut infected = Ok(None);

                loop {
                    for (next, &connected) in graph[node].iter().enumerate() {
                        if connected != 0 {
                            match &mut states[next] {
                                state @ State::NotVisited => {
                                    *state = State::Visited;
                                    size += 1;
                                    queue.push_back(next);
                                }
                                State::Visited => {}
                                State::Infected => match infected {
                                    Ok(None) => infected = Ok(Some(next)),
                                    Ok(Some(current_infected)) => {
                                        if current_infected != next {
                                            infected = Err(());
                                        }
                                    }
                                    Err(()) => {}
                                },
                            }
                        }
                    }

                    if let Some(next_node) = queue.pop_front() {
                        node = next_node;
                    } else {
                        break;
                    }
                }

                if let Ok(Some(current_infected)) = infected {
                    affects[current_infected] += size;
                }
            }
        }

        // Find the infected node that affects most nodes.

        (0_u32..)
            .zip(affects)
            .filter_map(|(node, size)| if size == 0 { None } else { Some((size, Reverse(node))) })
            .max()
            .map_or_else(
                || initial.iter().copied().min().unwrap() as _,
                |(_, Reverse(node))| node,
            ) as _
    }
}

// ------------------------------------------------------ snip ------------------------------------------------------ //

impl super::Solution for Solution {
    fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        Self::min_malware_spread(graph, initial)
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_solution() {
        super::super::tests::run::<super::Solution>();
    }
}
